import "../lib.rpl";

pastreq pattern always1(formulas : A) from Always with always_inv;
pasteinv pattern always_inv(formulas : A) from Always;

pasteinv pattern previous_inv(formulas : A) from Previous lemmas {
	LS7 lemma prevous_one_point {
	extra invariant formulas : A1
	requirement formulas : A
	init state : s0
	final state : s
	premise previous_inv(formulas : A1 current s0)
	};
};

futurereq pattern constrained_until(const : t formulas : A1, A2) from ../Constrained_Until with constrained_until_inv;
futureeinv pattern constrained_until_inv(const : t fun : t1 formulas : A1, A2) lemmas {
	LS2 lemma constrained_until_one_point {
	const : t
	fun : t1
	extra invariant formulas : A1, A2
	final state : s
	premise A2(s, s) \/ frm(t1(s) > 0) /\ A1(s)
	};
	LS1 lemma constrained_until_rule {
	const : t
	fun : t1
	extra invariant formulas : A1, A2
	init state : s0
	final state : s
	premise alwaysimp(s0, A1(s0), A1(s)) /\ alwaysimp(s0, A2(s0), A2(s)) /\ (frm(t1(s0) == 0) \/ A2(s, s) /\ frm(t1(s0) <= t) \/ A1(s, s) 
		/\ frm(t1(s0) < t1(s))
	)
	};
	LS3 lemma constrained_until_einv2req {
		const: t
		fun: t1
		extra invariant formulas: A1_1, A2_1
		requirement formulas: A1, A2
		final state : s
		premise alwaysimp(s, A1_1(s), A1(s)) /\ alwaysimp(s, A2_1(s), A2(s)) /\ frm(t1(s) <= t)
	};
};

derivedreq pattern P2(const : t formulas : A1, A2) from ../Pattern1 with P2_inv;

derivedreq pattern always(formulas : A1) from Patterns with always_inv;
derivedeinv pattern always_inv(formulas : A1) from Patterns lemmas {
	LS8 lemma always_rule {
		extra invariant formulas : A1
		init state : s0
		final state : s
		premise alwaysimp(s0, A1(s0), A1(s)) /\ A1(s, s)
	};
	LS9 lemma always_einv2req {
		extra invariant formulas : A1
		requirement formulas : A
		final state : s
		premise alwaysimp(s, A1(s), A(s))
	};
};


derivedreq pattern P1(const : t simple formulas : A1 formulas : A2, A3) = always(formulas : lambda r2 r1. 
	~A1(r1) \/ constrained_until(const : t formulas : A2, A3 final : r2 current : r1)
);


var hands, dryer;

requirement R1 = P1(const: 10 formulas: frm(False==False), lambda r1 r2. frm(r1[dryer] ~= True \/ hands==True),
	frm(dryer==True /\ hands==False)
);
requirement R2 : P2 with R2_inv;

extra invariant R1_inv for R1;
extra invariant R3_inv : P2_inv for R3;
