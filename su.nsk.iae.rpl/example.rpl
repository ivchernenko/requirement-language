import "Lib.rpl";

pastreq pattern always1(formulas : A)  with always_inv;
pasteinv pattern always_inv(formulas : A);

pasteinv pattern previous_inv(formulas : A) lemmas {
	LS7 lemma prevous_one_point {
	extra invariant formulas : A1
	requirement formulas : A
	init state : s0
	final state : s
	premise previous_inv(formulas : A1 current s0)
	};
};

futurereq pattern constrained_until(const : t formulas : A1, A2) with constrained_until_inv;
futureeinv pattern constrained_until_inv(const : t fun : t1 formulas : A1, A2) lemmas {
	LS2 lemma constrained_until_one_point {
	const : t
	fun : t1
	extra invariant formulas : A1, A2
	final state : s
	premise A2(s, s) \/ frm(t1(s) > 0) /\ A1(s)
	};
	LS1 lemma constrained_until_rule {
	const : t
	fun : t1
	extra invariant formulas : A1, A2
	init state : s0
	final state : s
	premise alwaysimp(s0, A1(s0), A1(s)) /\ alwaysimp(s0, A2(s0), A2(s)) /\ (frm(t1(s0) = 0) \/ A2(s, s) /\ frm(t1(s0) <= t) \/ A1(s, s) 
		/\ frm(t1(s0) < t1(s))
	)
	};
	LS3 lemma constrained_until_einv2req {
		const: t
		fun: t1
		extra invariant formulas: A1_1, A2_1
		requirement formulas: A1, A2
		final state : s
		premise alwaysimp(s, A1_1(s), A1(s)) /\ alwaysimp(s, A2_1(s), A2(s)) /\ frm(t1(s) <= t)
	};
};

derivedreq pattern always(formulas : A1) with always_inv;
derivedeinv pattern always_inv(formulas : A1) lemmas {
	LS8 lemma always_rule {
		extra invariant formulas : A1
		init state : s0
		final state : s
		premise alwaysimp(s0, A1(s0), A1(s)) /\ A1(s, s)
	};
	LS9 lemma always_einv2req {
		extra invariant formulas : A1
		requirement formulas : A
		final state : s
		premise alwaysimp(s, A1(s), A(s))
	};
};


derivedreq pattern P1(const : t simple formulas : A1 formulas : A2, A3) = always(formulas : lambda r2 r1. 
	~A1(r1) \/ constrained_until(const : t formulas : A2, A3 final : r2 current : r1)
);


var hands, dryer;


