import "Lib.rpl"; derivedeinv pattern P1_inv ( const : t formulas : A2_1 , A3_1 ) lemmas { LS8 lemma P1_inv_saving_gen { const : t premise ( True AND alwaysimp ( s0 , A2_1 ( s0 ) , A2_1 ( s ) ) AND alwaysimp ( s0 , A3_1 ( s0 ) , A3_1 ( s ) ) AND ( frm ( t1_0 ( s0 ) = 0 ) OR A3_1 ( s , s ) AND frm ( t1_0 ( s0 ) <= t ) OR A2_1 ( s , s ) AND frm ( t1_0 ( s0 ) < t1_0 ( s ) ) ) ) AND ( NOT A1 ( s ) OR A3_1 ( s , s ) OR frm ( t1_0 ( s ) > 0 ) AND A2_1 ( s , s ) ) } ; LS9 lemma P1einv_imp_req_gen { const : t requirement formulas : A2 requirement formulas : A3 premise True AND alwaysimp ( s0 , A2_1 ( s0 ) , A2 ( s0 ) ) AND alwaysimp ( s0 , A3_1 ( s0 ) , A3 ( s0 ) ) AND frm ( t1_0 ( s0 ) <= t ) } ; } ; derivedeinv pattern P1_inv_part_inv ( fun : t1_0 simple formulas : A2 , A3 ) lemmas { LS8 lemma P1_inv_saving { const : t final state : s premise ( frm ( t1_0 ( s0 ) = 0 ) OR A3 ( s ) AND frm ( t1_0 ( s0 ) <= t ) OR A2 ( s ) AND frm ( t1_0 ( s0 ) < t1_0 ( s ) ) ) AND ( NOT A1 ( s ) OR A3 ( s ) OR frm ( t1_0 ( s ) > 0 ) AND A2 ( s ) ) } ; LS9 lemma P1einv_imp_req { const : t final state : s0 premise frm ( t1_0 ( s ) <= t ) } ; } ; derivedreq pattern P1 ( formulas : A2 , A3 ) with P1_inv ; derivedreq pattern example_part ( simple formulas : A1 , A2 , A3 ) with P1_inv_part_inv ;