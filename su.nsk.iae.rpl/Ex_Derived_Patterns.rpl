import "Basic_Patterns.rpl" ; import "Derived_Patterns.rpl" ; derivedeinv pattern EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv ( const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale formulas : release_1 , Inv_1 , reaction_1 ) lemmas { LS8 lemma EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv_saving_gen { const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale extra invariant formulas : release_1 , Inv_1 , reaction_1 init state : s0 final state : s premise ( ( ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release_1 ( s , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) AND True ) AND ( alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release_1 ( s , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction_1 ( s , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) ) AND ( frm ( t1_0 ( s0 ) < finalt + 1 ) AND ( ( release_1 ( s , s ) OR finale ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) AND frm ( t1_0 ( s ) <= finalt + 1 + 1 ) OR frm ( t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) AND Inv_1 ( s , s ) AND NOT finale ( s ) ) OR frm ( t1_0 ( s0 ) >= finalt + 1 AND t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) ) ) AND ( frm ( b_0 ( s0 ) ) AND True OR release_1 ( s , s ) OR ( release_1 ( s , s ) OR finale ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( t1_0 ( s ) = 0 ) AND Inv_1 ( s , s ) AND NOT finale ( s ) ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) ) AND ( ( ( ( ( True AND True ) AND True ) AND alwaysimp ( s0 , lambda r1 . reaction_1 ( s0 , r1 ) , lambda r1 . reaction_1 ( s , r1 ) ) ) AND ( ( frm ( finalt > 0 ) OR finale ( s ) ) AND ( ( frm ( b_1 ( s0 ) ) AND True OR finale ( s ) ) OR frm ( b_2 ( s0 ) ) AND ( True AND True ) AND True AND frm ( t1_1_0 ( s0 ) < finalt AND finalt <= t2_1_0 ( s0 ) + 1 ) ) OR reaction_1 ( s , s ) ) ) AND ( b_2 ( s ) --> ( frm ( t1_1_0 ( s ) > 0 ) OR finale ( s ) ) AND ( ( frm ( b_1 ( s0 ) ) AND True OR finale ( s ) ) OR frm ( b_2 ( s0 ) ) AND ( True AND True ) AND True AND frm ( t1_1_0 ( s0 ) < t1_1_0 ( s ) AND t2_1_0 ( s ) <= t2_1_0 ( s0 ) + 1 ) ) ) ) AND ( b_1 ( s ) --> NOT trigger ( s ) ) } ; LS9 lemma EDTL_trigger_prev_final_nontemporal_or_tau_delay_trueeinv_imp_req_gen { const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale extra invariant formulas : release_1 , Inv_1 , reaction_1 requirement formulas : release , Inv , reaction final state : s0 premise ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release ( s0 , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) AND True ) AND alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release ( s0 , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction ( s0 , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) ) AND ( ( True AND True ) AND True ) AND alwaysimp ( s0 , lambda r1 . reaction_1 ( s0 , r1 ) , lambda r1 . reaction ( s0 , r1 ) ) } ; } ; derivedeinv pattern EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv_part ( const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale , release , Inv , reaction ) lemmas { LS8 lemma EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv_saving { const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale , release , Inv , reaction init state : s0 final state : s premise ( ( ( frm ( t1_0 ( s0 ) < finalt + 1 ) AND ( ( release ( s ) OR finale ( s ) AND reaction ( s ) AND Inv ( s ) ) AND frm ( t1_0 ( s ) <= finalt + 1 + 1 ) OR frm ( t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) AND Inv ( s ) AND NOT finale ( s ) ) OR frm ( t1_0 ( s0 ) >= finalt + 1 AND t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) ) AND ( frm ( b_0 ( s0 ) ) OR release ( s ) OR ( release ( s ) OR finale ( s ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( t1_0 ( s ) = 0 ) AND Inv ( s ) AND NOT finale ( s ) ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) ) AND ( ( ( frm ( finalt > 0 ) OR finale ( s ) ) AND ( ( frm ( b_1 ( s0 ) ) OR finale ( s ) ) OR frm ( b_2 ( s0 ) ) AND frm ( t1_1_0 ( s0 ) < finalt AND finalt <= t2_1_0 ( s0 ) + 1 ) ) OR reaction ( s ) ) AND ( b_2 ( s ) --> ( frm ( t1_1_0 ( s ) > 0 ) OR finale ( s ) ) AND ( ( frm ( b_1 ( s0 ) ) OR finale ( s ) ) OR frm ( b_2 ( s0 ) ) AND frm ( t1_1_0 ( s0 ) < t1_1_0 ( s ) AND t2_1_0 ( s ) <= t2_1_0 ( s0 ) + 1 ) ) ) ) AND ( b_1 ( s ) --> NOT trigger ( s ) ) } ; LS9 lemma EDTL_trigger_prev_final_nontemporal_or_tau_delay_trueeinv_imp_req { const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale , release , Inv , reaction final state : s premise True } ; } ; derivedreq pattern EDTL_trigger_prev_final_nontemporal_or_tau_delay_true ( const : finalt simple formulas : trigger , finale formulas : release , Inv , reaction ) with EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv ; derivedreq pattern EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_part ( const : finalt simple formulas : trigger , finale , release , Inv , reaction ) with EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv_part ;