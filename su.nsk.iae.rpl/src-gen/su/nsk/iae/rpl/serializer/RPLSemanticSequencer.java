/*
 * generated by Xtext 2.36.0
 */
package su.nsk.iae.rpl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import su.nsk.iae.rpl.rPL.AddTerm;
import su.nsk.iae.rpl.rPL.AlwaysImplication;
import su.nsk.iae.rpl.rPL.AlwaysImplicationParameterValue;
import su.nsk.iae.rpl.rPL.AtomicFormula;
import su.nsk.iae.rpl.rPL.BasicRequirementPatternInstance;
import su.nsk.iae.rpl.rPL.CompareTerm;
import su.nsk.iae.rpl.rPL.Conjunction;
import su.nsk.iae.rpl.rPL.ConjunctionInnerFormula;
import su.nsk.iae.rpl.rPL.ConjunctionLemmaPremiseFormula;
import su.nsk.iae.rpl.rPL.ConjunctionPatternFreeFormula;
import su.nsk.iae.rpl.rPL.ConjunctionTerm;
import su.nsk.iae.rpl.rPL.Constant;
import su.nsk.iae.rpl.rPL.ConstantParameter;
import su.nsk.iae.rpl.rPL.DerivedExtraInvariantPattern;
import su.nsk.iae.rpl.rPL.DerivedLemmas;
import su.nsk.iae.rpl.rPL.DerivedRequirementPattern;
import su.nsk.iae.rpl.rPL.DisjunctionLemmaPremiseFormula;
import su.nsk.iae.rpl.rPL.EqTerm;
import su.nsk.iae.rpl.rPL.ExtraInvariant;
import su.nsk.iae.rpl.rPL.Formula;
import su.nsk.iae.rpl.rPL.FormulaParameterValue;
import su.nsk.iae.rpl.rPL.FunApplication;
import su.nsk.iae.rpl.rPL.FunctionalParameter;
import su.nsk.iae.rpl.rPL.FutureExtraInvariantPattern;
import su.nsk.iae.rpl.rPL.FutureLemmas;
import su.nsk.iae.rpl.rPL.FutureRequirementPattern;
import su.nsk.iae.rpl.rPL.Import;
import su.nsk.iae.rpl.rPL.InnerFormula;
import su.nsk.iae.rpl.rPL.IntegerLiteral;
import su.nsk.iae.rpl.rPL.Lemma;
import su.nsk.iae.rpl.rPL.LemmaPremiseFormula;
import su.nsk.iae.rpl.rPL.Model;
import su.nsk.iae.rpl.rPL.MulTerm;
import su.nsk.iae.rpl.rPL.NegationFormula;
import su.nsk.iae.rpl.rPL.NegationTerm;
import su.nsk.iae.rpl.rPL.OuterRequirementPatternInstance;
import su.nsk.iae.rpl.rPL.PastExtraInvariantPattern;
import su.nsk.iae.rpl.rPL.PastExtraInvariantPatternInstance;
import su.nsk.iae.rpl.rPL.PastLemmas;
import su.nsk.iae.rpl.rPL.PastRequirementPattern;
import su.nsk.iae.rpl.rPL.PatternFreeFormula;
import su.nsk.iae.rpl.rPL.PatternFreeFormulaParameterValue;
import su.nsk.iae.rpl.rPL.PowerTerm;
import su.nsk.iae.rpl.rPL.PrimaryFormula;
import su.nsk.iae.rpl.rPL.PrimaryInnerFormula;
import su.nsk.iae.rpl.rPL.PrimaryLemmaPremiseFormula;
import su.nsk.iae.rpl.rPL.PrimaryPatternFreeFormula;
import su.nsk.iae.rpl.rPL.PrimaryTerm;
import su.nsk.iae.rpl.rPL.ProgramVariable;
import su.nsk.iae.rpl.rPL.RPLPackage;
import su.nsk.iae.rpl.rPL.RealLiteral;
import su.nsk.iae.rpl.rPL.RegularFormulaParameter;
import su.nsk.iae.rpl.rPL.Requirement;
import su.nsk.iae.rpl.rPL.SimpleFormulaParameter;
import su.nsk.iae.rpl.rPL.Term;
import su.nsk.iae.rpl.rPL.UnaryTerm;
import su.nsk.iae.rpl.rPL.UpdateStateVariable;
import su.nsk.iae.rpl.rPL.VarDeclaration;
import su.nsk.iae.rpl.services.RPLGrammarAccess;

@SuppressWarnings("all")
public class RPLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RPLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RPLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RPLPackage.ADD_TERM:
				sequence_AddTerm(context, (AddTerm) semanticObject); 
				return; 
			case RPLPackage.ALWAYS_IMPLICATION:
				sequence_AlwaysImplication(context, (AlwaysImplication) semanticObject); 
				return; 
			case RPLPackage.ALWAYS_IMPLICATION_PARAMETER_VALUE:
				sequence_AlwaysImplicationParameterValue(context, (AlwaysImplicationParameterValue) semanticObject); 
				return; 
			case RPLPackage.ATOMIC_FORMULA:
				sequence_AtomicFormula(context, (AtomicFormula) semanticObject); 
				return; 
			case RPLPackage.BASIC_REQUIREMENT_PATTERN_INSTANCE:
				sequence_BasicRequirementPatternInstance(context, (BasicRequirementPatternInstance) semanticObject); 
				return; 
			case RPLPackage.COMPARE_TERM:
				sequence_CompareTerm(context, (CompareTerm) semanticObject); 
				return; 
			case RPLPackage.CONJUNCTION:
				sequence_ConjunctionFormula(context, (Conjunction) semanticObject); 
				return; 
			case RPLPackage.CONJUNCTION_INNER_FORMULA:
				sequence_ConjunctionInnerFormula(context, (ConjunctionInnerFormula) semanticObject); 
				return; 
			case RPLPackage.CONJUNCTION_LEMMA_PREMISE_FORMULA:
				sequence_ConjunctionLemmaPremiseFormula(context, (ConjunctionLemmaPremiseFormula) semanticObject); 
				return; 
			case RPLPackage.CONJUNCTION_PATTERN_FREE_FORMULA:
				sequence_ConjunctionPatternFreeFormula(context, (ConjunctionPatternFreeFormula) semanticObject); 
				return; 
			case RPLPackage.CONJUNCTION_TERM:
				sequence_ConjunctionTerm(context, (ConjunctionTerm) semanticObject); 
				return; 
			case RPLPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case RPLPackage.CONSTANT_PARAMETER:
				sequence_ConstantParameter(context, (ConstantParameter) semanticObject); 
				return; 
			case RPLPackage.DERIVED_EXTRA_INVARIANT_PATTERN:
				sequence_DerivedExtraInvariantPattern(context, (DerivedExtraInvariantPattern) semanticObject); 
				return; 
			case RPLPackage.DERIVED_LEMMAS:
				sequence_DerivedLemmas(context, (DerivedLemmas) semanticObject); 
				return; 
			case RPLPackage.DERIVED_REQUIREMENT_PATTERN:
				sequence_DerivedRequirementPattern(context, (DerivedRequirementPattern) semanticObject); 
				return; 
			case RPLPackage.DISJUNCTION_LEMMA_PREMISE_FORMULA:
				sequence_DisjunctionLemmaPremiseFormula(context, (DisjunctionLemmaPremiseFormula) semanticObject); 
				return; 
			case RPLPackage.EQ_TERM:
				sequence_EqTerm(context, (EqTerm) semanticObject); 
				return; 
			case RPLPackage.EXTRA_INVARIANT:
				sequence_ExtraInvariant(context, (ExtraInvariant) semanticObject); 
				return; 
			case RPLPackage.FORMULA:
				sequence_Formula(context, (Formula) semanticObject); 
				return; 
			case RPLPackage.FORMULA_PARAMETER_VALUE:
				sequence_FormulaParameterValue(context, (FormulaParameterValue) semanticObject); 
				return; 
			case RPLPackage.FUN_APPLICATION:
				sequence_FunApplication(context, (FunApplication) semanticObject); 
				return; 
			case RPLPackage.FUNCTIONAL_PARAMETER:
				sequence_FunctionalParameter(context, (FunctionalParameter) semanticObject); 
				return; 
			case RPLPackage.FUTURE_EXTRA_INVARIANT_PATTERN:
				sequence_FutureExtraInvariantPattern(context, (FutureExtraInvariantPattern) semanticObject); 
				return; 
			case RPLPackage.FUTURE_LEMMAS:
				sequence_FutureLemmas(context, (FutureLemmas) semanticObject); 
				return; 
			case RPLPackage.FUTURE_REQUIREMENT_PATTERN:
				sequence_FutureRequirementPattern(context, (FutureRequirementPattern) semanticObject); 
				return; 
			case RPLPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case RPLPackage.INNER_FORMULA:
				sequence_InnerFormula(context, (InnerFormula) semanticObject); 
				return; 
			case RPLPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case RPLPackage.LEMMA:
				sequence_Lemma(context, (Lemma) semanticObject); 
				return; 
			case RPLPackage.LEMMA_PREMISE_FORMULA:
				sequence_LemmaPremiseFormula(context, (LemmaPremiseFormula) semanticObject); 
				return; 
			case RPLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case RPLPackage.MUL_TERM:
				sequence_MulTerm(context, (MulTerm) semanticObject); 
				return; 
			case RPLPackage.NEGATION_FORMULA:
				sequence_NegationFormula(context, (NegationFormula) semanticObject); 
				return; 
			case RPLPackage.NEGATION_TERM:
				sequence_NegationTerm(context, (NegationTerm) semanticObject); 
				return; 
			case RPLPackage.OUTER_REQUIREMENT_PATTERN_INSTANCE:
				sequence_OuterRequirementPatternInstance(context, (OuterRequirementPatternInstance) semanticObject); 
				return; 
			case RPLPackage.PAST_EXTRA_INVARIANT_PATTERN:
				sequence_PastExtraInvariantPattern(context, (PastExtraInvariantPattern) semanticObject); 
				return; 
			case RPLPackage.PAST_EXTRA_INVARIANT_PATTERN_INSTANCE:
				sequence_PastExtraInvariantPatternInstance(context, (PastExtraInvariantPatternInstance) semanticObject); 
				return; 
			case RPLPackage.PAST_LEMMAS:
				sequence_PastLemmas(context, (PastLemmas) semanticObject); 
				return; 
			case RPLPackage.PAST_REQUIREMENT_PATTERN:
				sequence_PastRequirementPattern(context, (PastRequirementPattern) semanticObject); 
				return; 
			case RPLPackage.PATTERN_FREE_FORMULA:
				sequence_PatternFreeFormula(context, (PatternFreeFormula) semanticObject); 
				return; 
			case RPLPackage.PATTERN_FREE_FORMULA_PARAMETER_VALUE:
				sequence_PatternFreeFormulaParameterValue(context, (PatternFreeFormulaParameterValue) semanticObject); 
				return; 
			case RPLPackage.POWER_TERM:
				sequence_PowerTerm(context, (PowerTerm) semanticObject); 
				return; 
			case RPLPackage.PRIMARY_FORMULA:
				sequence_PrimaryFormula(context, (PrimaryFormula) semanticObject); 
				return; 
			case RPLPackage.PRIMARY_INNER_FORMULA:
				sequence_PrimaryInnerFormula(context, (PrimaryInnerFormula) semanticObject); 
				return; 
			case RPLPackage.PRIMARY_LEMMA_PREMISE_FORMULA:
				sequence_PrimaryLemmaPremiseFormula(context, (PrimaryLemmaPremiseFormula) semanticObject); 
				return; 
			case RPLPackage.PRIMARY_PATTERN_FREE_FORMULA:
				sequence_PrimaryPatternFreeFormula(context, (PrimaryPatternFreeFormula) semanticObject); 
				return; 
			case RPLPackage.PRIMARY_TERM:
				sequence_PrimaryTerm(context, (PrimaryTerm) semanticObject); 
				return; 
			case RPLPackage.PROGRAM_VARIABLE:
				sequence_ProgramVariable(context, (ProgramVariable) semanticObject); 
				return; 
			case RPLPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case RPLPackage.REGULAR_FORMULA_PARAMETER:
				sequence_RegularFormulaParameter(context, (RegularFormulaParameter) semanticObject); 
				return; 
			case RPLPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case RPLPackage.SIMPLE_FORMULA_PARAMETER:
				sequence_SimpleFormulaParameter(context, (SimpleFormulaParameter) semanticObject); 
				return; 
			case RPLPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case RPLPackage.UNARY_TERM:
				sequence_UnaryTerm(context, (UnaryTerm) semanticObject); 
				return; 
			case RPLPackage.UPDATE_STATE_VARIABLE:
				sequence_UpdateStateVariable(context, (UpdateStateVariable) semanticObject); 
				return; 
			case RPLPackage.VAR_DECLARATION:
				sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns AddTerm
	 *     Term.Term_1_0 returns AddTerm
	 *     ConjunctionTerm returns AddTerm
	 *     ConjunctionTerm.ConjunctionTerm_1_0 returns AddTerm
	 *     NegationTerm returns AddTerm
	 *     EqTerm returns AddTerm
	 *     EqTerm.EqTerm_1_0 returns AddTerm
	 *     CompareTerm returns AddTerm
	 *     CompareTerm.CompareTerm_1_0 returns AddTerm
	 *     AddTerm returns AddTerm
	 *     AddTerm.AddTerm_1_0 returns AddTerm
	 *
	 * Constraint:
	 *     (left=AddTerm_AddTerm_1_0 addOp=AddOperator right=AddTerm)
	 * </pre>
	 */
	protected void sequence_AddTerm(ISerializationContext context, AddTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.ADD_TERM__ADD_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.ADD_TERM__ADD_OP));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddTermAccess().getAddTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddTermAccess().getAddOpAddOperatorEnumRuleCall_1_1_0(), semanticObject.getAddOp());
		feeder.accept(grammarAccess.getAddTermAccess().getRightAddTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AlwaysImplicationParameterValue returns AlwaysImplicationParameterValue
	 *
	 * Constraint:
	 *     (state=UpdateStateVariable? formula=NegationFormula)
	 * </pre>
	 */
	protected void sequence_AlwaysImplicationParameterValue(ISerializationContext context, AlwaysImplicationParameterValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AlwaysImplication returns AlwaysImplication
	 *
	 * Constraint:
	 *     (state=[UpdateStateVariable|ID] left=AlwaysImplicationParameterValue right=AlwaysImplicationParameterValue)
	 * </pre>
	 */
	protected void sequence_AlwaysImplication(ISerializationContext context, AlwaysImplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.ALWAYS_IMPLICATION__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.ALWAYS_IMPLICATION__STATE));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.ALWAYS_IMPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.ALWAYS_IMPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.ALWAYS_IMPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.ALWAYS_IMPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAlwaysImplicationAccess().getStateUpdateStateVariableIDTerminalRuleCall_2_0_1(), semanticObject.eGet(RPLPackage.Literals.ALWAYS_IMPLICATION__STATE, false));
		feeder.accept(grammarAccess.getAlwaysImplicationAccess().getLeftAlwaysImplicationParameterValueParserRuleCall_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAlwaysImplicationAccess().getRightAlwaysImplicationParameterValueParserRuleCall_6_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AtomicFormula returns AtomicFormula
	 *
	 * Constraint:
	 *     (
	 *         boolLiteral=BOOLEAN_LITERAL | 
	 *         boolTerm=Term | 
	 *         (fmParam=[FormulaParameter|ID] (states+=[UpdateStateVariable|ID] states+=[UpdateStateVariable|ID]*)?)
	 *     )
	 * </pre>
	 */
	protected void sequence_AtomicFormula(ISerializationContext context, AtomicFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BasicRequirementPatternInstance returns BasicRequirementPatternInstance
	 *
	 * Constraint:
	 *     (
	 *         pattern=[BasicRequirementPattern|ID] 
	 *         (cParams+=Term cParams+=Term*)? 
	 *         (fmParams+=FormulaParameterValue fmParams+=FormulaParameterValue*)? 
	 *         (finState=[UpdateStateVariable|ID] curState=[UpdateStateVariable|ID]?)?
	 *     )
	 * </pre>
	 */
	protected void sequence_BasicRequirementPatternInstance(ISerializationContext context, BasicRequirementPatternInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns CompareTerm
	 *     Term.Term_1_0 returns CompareTerm
	 *     ConjunctionTerm returns CompareTerm
	 *     ConjunctionTerm.ConjunctionTerm_1_0 returns CompareTerm
	 *     NegationTerm returns CompareTerm
	 *     EqTerm returns CompareTerm
	 *     EqTerm.EqTerm_1_0 returns CompareTerm
	 *     CompareTerm returns CompareTerm
	 *     CompareTerm.CompareTerm_1_0 returns CompareTerm
	 *
	 * Constraint:
	 *     (left=CompareTerm_CompareTerm_1_0 compPred=CompPredicate right=CompareTerm)
	 * </pre>
	 */
	protected void sequence_CompareTerm(ISerializationContext context, CompareTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.COMPARE_TERM__COMP_PRED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.COMPARE_TERM__COMP_PRED));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareTermAccess().getCompareTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareTermAccess().getCompPredCompPredicateEnumRuleCall_1_1_0(), semanticObject.getCompPred());
		feeder.accept(grammarAccess.getCompareTermAccess().getRightCompareTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Formula returns Conjunction
	 *     Formula.Formula_1_0 returns Conjunction
	 *     ConjunctionFormula returns Conjunction
	 *     ConjunctionFormula.Conjunction_1_0 returns Conjunction
	 *
	 * Constraint:
	 *     (left=ConjunctionFormula_Conjunction_1_0 right=ConjunctionFormula)
	 * </pre>
	 */
	protected void sequence_ConjunctionFormula(ISerializationContext context, Conjunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.FORMULA__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.FORMULA__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.FORMULA__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.FORMULA__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConjunctionFormulaAccess().getConjunctionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConjunctionFormulaAccess().getRightConjunctionFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InnerFormula returns ConjunctionInnerFormula
	 *     InnerFormula.InnerFormula_1_0 returns ConjunctionInnerFormula
	 *     ConjunctionInnerFormula returns ConjunctionInnerFormula
	 *     ConjunctionInnerFormula.ConjunctionInnerFormula_1_0 returns ConjunctionInnerFormula
	 *
	 * Constraint:
	 *     (left=ConjunctionInnerFormula_ConjunctionInnerFormula_1_0 right=ConjunctionInnerFormula)
	 * </pre>
	 */
	protected void sequence_ConjunctionInnerFormula(ISerializationContext context, ConjunctionInnerFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.INNER_FORMULA__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.INNER_FORMULA__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.INNER_FORMULA__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.INNER_FORMULA__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConjunctionInnerFormulaAccess().getConjunctionInnerFormulaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConjunctionInnerFormulaAccess().getRightConjunctionInnerFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LemmaPremiseFormula returns ConjunctionLemmaPremiseFormula
	 *     DisjunctionLemmaPremiseFormula returns ConjunctionLemmaPremiseFormula
	 *     DisjunctionLemmaPremiseFormula.DisjunctionLemmaPremiseFormula_1_0 returns ConjunctionLemmaPremiseFormula
	 *     ConjunctionLemmaPremiseFormula returns ConjunctionLemmaPremiseFormula
	 *     ConjunctionLemmaPremiseFormula.ConjunctionLemmaPremiseFormula_1_0 returns ConjunctionLemmaPremiseFormula
	 *
	 * Constraint:
	 *     (left=ConjunctionLemmaPremiseFormula_ConjunctionLemmaPremiseFormula_1_0 right=ConjunctionLemmaPremiseFormula)
	 * </pre>
	 */
	protected void sequence_ConjunctionLemmaPremiseFormula(ISerializationContext context, ConjunctionLemmaPremiseFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConjunctionLemmaPremiseFormulaAccess().getConjunctionLemmaPremiseFormulaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConjunctionLemmaPremiseFormulaAccess().getRightConjunctionLemmaPremiseFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PatternFreeFormula returns ConjunctionPatternFreeFormula
	 *     PatternFreeFormula.PatternFreeFormula_1_0 returns ConjunctionPatternFreeFormula
	 *     ConjunctionPatternFreeFormula returns ConjunctionPatternFreeFormula
	 *     ConjunctionPatternFreeFormula.ConjunctionPatternFreeFormula_1_0 returns ConjunctionPatternFreeFormula
	 *
	 * Constraint:
	 *     (left=ConjunctionPatternFreeFormula_ConjunctionPatternFreeFormula_1_0 right=ConjunctionPatternFreeFormula)
	 * </pre>
	 */
	protected void sequence_ConjunctionPatternFreeFormula(ISerializationContext context, ConjunctionPatternFreeFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.PATTERN_FREE_FORMULA__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.PATTERN_FREE_FORMULA__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.PATTERN_FREE_FORMULA__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.PATTERN_FREE_FORMULA__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConjunctionPatternFreeFormulaAccess().getConjunctionPatternFreeFormulaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConjunctionPatternFreeFormulaAccess().getRightConjunctionPatternFreeFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns ConjunctionTerm
	 *     Term.Term_1_0 returns ConjunctionTerm
	 *     ConjunctionTerm returns ConjunctionTerm
	 *     ConjunctionTerm.ConjunctionTerm_1_0 returns ConjunctionTerm
	 *
	 * Constraint:
	 *     (left=ConjunctionTerm_ConjunctionTerm_1_0 right=ConjunctionTerm)
	 * </pre>
	 */
	protected void sequence_ConjunctionTerm(ISerializationContext context, ConjunctionTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConjunctionTermAccess().getConjunctionTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConjunctionTermAccess().getRightConjunctionTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns ConstantParameter
	 *     ConstantParameter returns ConstantParameter
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_ConstantParameter(ISerializationContext context, ConstantParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantParameterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     (num=NumericLiteral | bool=BOOLEAN_LITERAL)
	 * </pre>
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns DerivedExtraInvariantPattern
	 *     DerivedExtraInvariantPattern returns DerivedExtraInvariantPattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (cParams+=ConstantParameter cParams+=ConstantParameter*)? 
	 *         (fnParams+=FunctionalParameter fnParams+=FunctionalParameter*)? 
	 *         (simpleFmParams+=SimpleFormulaParameter simpleFmParams+=SimpleFormulaParameter*)? 
	 *         (fmParams+=RegularFormulaParameter fmParams+=RegularFormulaParameter*)? 
	 *         lemmas=DerivedLemmas?
	 *     )
	 * </pre>
	 */
	protected void sequence_DerivedExtraInvariantPattern(ISerializationContext context, DerivedExtraInvariantPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DerivedLemmas returns DerivedLemmas
	 *
	 * Constraint:
	 *     (L8=Lemma | L9=Lemma)*
	 * </pre>
	 */
	protected void sequence_DerivedLemmas(ISerializationContext context, DerivedLemmas semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns DerivedRequirementPattern
	 *     BasicRequirementPattern returns DerivedRequirementPattern
	 *     DerivedRequirementPattern returns DerivedRequirementPattern
	 *     OuterRequirementPattern returns DerivedRequirementPattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (cParams+=ConstantParameter cParams+=ConstantParameter*)? 
	 *         (simpleFmParams+=SimpleFormulaParameter simpleFmParams+=SimpleFormulaParameter*)? 
	 *         (fmParams+=RegularFormulaParameter fmParams+=RegularFormulaParameter*)? 
	 *         (definition=Formula | extraInvPattern=[DerivedExtraInvariantPattern|ID]) 
	 *         lemmas=DerivedLemmas?
	 *     )
	 * </pre>
	 */
	protected void sequence_DerivedRequirementPattern(ISerializationContext context, DerivedRequirementPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LemmaPremiseFormula returns DisjunctionLemmaPremiseFormula
	 *     DisjunctionLemmaPremiseFormula returns DisjunctionLemmaPremiseFormula
	 *     DisjunctionLemmaPremiseFormula.DisjunctionLemmaPremiseFormula_1_0 returns DisjunctionLemmaPremiseFormula
	 *
	 * Constraint:
	 *     (left=DisjunctionLemmaPremiseFormula_DisjunctionLemmaPremiseFormula_1_0 right=DisjunctionLemmaPremiseFormula)
	 * </pre>
	 */
	protected void sequence_DisjunctionLemmaPremiseFormula(ISerializationContext context, DisjunctionLemmaPremiseFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDisjunctionLemmaPremiseFormulaAccess().getDisjunctionLemmaPremiseFormulaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDisjunctionLemmaPremiseFormulaAccess().getRightDisjunctionLemmaPremiseFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns EqTerm
	 *     Term.Term_1_0 returns EqTerm
	 *     ConjunctionTerm returns EqTerm
	 *     ConjunctionTerm.ConjunctionTerm_1_0 returns EqTerm
	 *     NegationTerm returns EqTerm
	 *     EqTerm returns EqTerm
	 *     EqTerm.EqTerm_1_0 returns EqTerm
	 *
	 * Constraint:
	 *     (left=EqTerm_EqTerm_1_0 eqPred=EqPredicate right=EqTerm)
	 * </pre>
	 */
	protected void sequence_EqTerm(ISerializationContext context, EqTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.EQ_TERM__EQ_PRED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.EQ_TERM__EQ_PRED));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqTermAccess().getEqTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqTermAccess().getEqPredEqPredicateEnumRuleCall_1_1_0(), semanticObject.getEqPred());
		feeder.accept(grammarAccess.getEqTermAccess().getRightEqTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns ExtraInvariant
	 *     ExtraInvariant returns ExtraInvariant
	 *
	 * Constraint:
	 *     (name=ID pattern=[DerivedExtraInvariantPattern|ID])
	 * </pre>
	 */
	protected void sequence_ExtraInvariant(ISerializationContext context, ExtraInvariant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.EXTRA_INVARIANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.EXTRA_INVARIANT__NAME));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.EXTRA_INVARIANT__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.EXTRA_INVARIANT__PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtraInvariantAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExtraInvariantAccess().getPatternDerivedExtraInvariantPatternIDTerminalRuleCall_4_0_1(), semanticObject.eGet(RPLPackage.Literals.EXTRA_INVARIANT__PATTERN, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormulaParameterValue returns FormulaParameterValue
	 *
	 * Constraint:
	 *     (states+=UpdateStateVariable* formula=InnerFormula)
	 * </pre>
	 */
	protected void sequence_FormulaParameterValue(ISerializationContext context, FormulaParameterValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Formula returns Formula
	 *     Formula.Formula_1_0 returns Formula
	 *
	 * Constraint:
	 *     (left=Formula_Formula_1_0 right=Formula)
	 * </pre>
	 */
	protected void sequence_Formula(ISerializationContext context, Formula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.FORMULA__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.FORMULA__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.FORMULA__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.FORMULA__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormulaAccess().getFormulaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFormulaAccess().getRightFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunApplication returns FunApplication
	 *
	 * Constraint:
	 *     (fnParam=[FunctionalParameter|ID] state=[UpdateStateVariable|ID])
	 * </pre>
	 */
	protected void sequence_FunApplication(ISerializationContext context, FunApplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.FUN_APPLICATION__FN_PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.FUN_APPLICATION__FN_PARAM));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.FUN_APPLICATION__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.FUN_APPLICATION__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunApplicationAccess().getFnParamFunctionalParameterIDTerminalRuleCall_0_0_1(), semanticObject.eGet(RPLPackage.Literals.FUN_APPLICATION__FN_PARAM, false));
		feeder.accept(grammarAccess.getFunApplicationAccess().getStateUpdateStateVariableIDTerminalRuleCall_2_0_1(), semanticObject.eGet(RPLPackage.Literals.FUN_APPLICATION__STATE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionalParameter returns FunctionalParameter
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_FunctionalParameter(ISerializationContext context, FunctionalParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.FUNCTIONAL_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.FUNCTIONAL_PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionalParameterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns FutureExtraInvariantPattern
	 *     FutureExtraInvariantPattern returns FutureExtraInvariantPattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (cParams+=ConstantParameter cParams+=ConstantParameter*)? 
	 *         (fnParams+=FunctionalParameter fnParams+=FunctionalParameter*)? 
	 *         (fmParams+=RegularFormulaParameter fmParams+=RegularFormulaParameter*)? 
	 *         lemmas=FutureLemmas?
	 *     )
	 * </pre>
	 */
	protected void sequence_FutureExtraInvariantPattern(ISerializationContext context, FutureExtraInvariantPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FutureLemmas returns FutureLemmas
	 *
	 * Constraint:
	 *     (L1=Lemma | L2=Lemma | L3=Lemma)*
	 * </pre>
	 */
	protected void sequence_FutureLemmas(ISerializationContext context, FutureLemmas semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns FutureRequirementPattern
	 *     BasicRequirementPattern returns FutureRequirementPattern
	 *     FutureRequirementPattern returns FutureRequirementPattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (cParams+=ConstantParameter cParams+=ConstantParameter*)? 
	 *         (fmParams+=RegularFormulaParameter fmParams+=RegularFormulaParameter*)? 
	 *         extraInvPattern=[FutureExtraInvariantPattern|ID] 
	 *         lessas=FutureLemmas?
	 *     )
	 * </pre>
	 */
	protected void sequence_FutureRequirementPattern(ISerializationContext context, FutureRequirementPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (importURI=STRING session=STRING?)
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InnerFormula returns InnerFormula
	 *     InnerFormula.InnerFormula_1_0 returns InnerFormula
	 *
	 * Constraint:
	 *     (left=InnerFormula_InnerFormula_1_0 right=InnerFormula)
	 * </pre>
	 */
	protected void sequence_InnerFormula(ISerializationContext context, InnerFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.INNER_FORMULA__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.INNER_FORMULA__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.INNER_FORMULA__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.INNER_FORMULA__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInnerFormulaAccess().getInnerFormulaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getInnerFormulaAccess().getRightInnerFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NumericLiteral returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     (sig?='-'? value=INTEGER)
	 * </pre>
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LemmaPremiseFormula returns LemmaPremiseFormula
	 *
	 * Constraint:
	 *     (left=FunApplication right=LemmaPremiseFormula)
	 * </pre>
	 */
	protected void sequence_LemmaPremiseFormula(ISerializationContext context, LemmaPremiseFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.LEMMA_PREMISE_FORMULA__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLemmaPremiseFormulaAccess().getLeftFunApplicationParserRuleCall_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLemmaPremiseFormulaAccess().getRightLemmaPremiseFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Lemma returns Lemma
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (cVars+=ConstantParameter cVars+=ConstantParameter*)? 
	 *         (fnVars+=FunctionalParameter fnVars+=FunctionalParameter*)? 
	 *         (simpleFmVars+=SimpleFormulaParameter simpleFmVars+=SimpleFormulaParameter*)? 
	 *         (ifmVars+=RegularFormulaParameter ifmVars+=RegularFormulaParameter*)? 
	 *         (rfmVars+=RegularFormulaParameter rfmVars+=RegularFormulaParameter*)? 
	 *         initState=UpdateStateVariable? 
	 *         finalState=UpdateStateVariable 
	 *         prem=LemmaPremiseFormula
	 *     )
	 * </pre>
	 */
	protected void sequence_Lemma(ISerializationContext context, Lemma semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     ((imports+=Import+ elements+=Element+) | elements+=Element+)?
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns MulTerm
	 *     Term.Term_1_0 returns MulTerm
	 *     ConjunctionTerm returns MulTerm
	 *     ConjunctionTerm.ConjunctionTerm_1_0 returns MulTerm
	 *     NegationTerm returns MulTerm
	 *     EqTerm returns MulTerm
	 *     EqTerm.EqTerm_1_0 returns MulTerm
	 *     CompareTerm returns MulTerm
	 *     CompareTerm.CompareTerm_1_0 returns MulTerm
	 *     AddTerm returns MulTerm
	 *     AddTerm.AddTerm_1_0 returns MulTerm
	 *     MulTerm returns MulTerm
	 *     MulTerm.MulTerm_1_0 returns MulTerm
	 *
	 * Constraint:
	 *     (left=MulTerm_MulTerm_1_0 mulOp=MulOperator right=MulTerm)
	 * </pre>
	 */
	protected void sequence_MulTerm(ISerializationContext context, MulTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.MUL_TERM__MUL_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.MUL_TERM__MUL_OP));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulTermAccess().getMulTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulTermAccess().getMulOpMulOperatorEnumRuleCall_1_1_0(), semanticObject.getMulOp());
		feeder.accept(grammarAccess.getMulTermAccess().getRightMulTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NegationFormula returns NegationFormula
	 *
	 * Constraint:
	 *     (neg?=NEGATION? right=AtomicFormula)
	 * </pre>
	 */
	protected void sequence_NegationFormula(ISerializationContext context, NegationFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns NegationTerm
	 *     Term.Term_1_0 returns NegationTerm
	 *     ConjunctionTerm returns NegationTerm
	 *     ConjunctionTerm.ConjunctionTerm_1_0 returns NegationTerm
	 *     NegationTerm returns NegationTerm
	 *
	 * Constraint:
	 *     right=EqTerm
	 * </pre>
	 */
	protected void sequence_NegationTerm(ISerializationContext context, NegationTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationTermAccess().getRightEqTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OuterRequirementPatternInstance returns OuterRequirementPatternInstance
	 *
	 * Constraint:
	 *     (
	 *         pattern=[OuterRequirementPattern|ID] 
	 *         (cParams+=Term cParams+=Term*)? 
	 *         (simpleFmParams+=PatternFreeFormulaParameterValue simpleFmParams+=PatternFreeFormulaParameterValue*)? 
	 *         (fmParams+=FormulaParameterValue fmParams+=FormulaParameterValue*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_OuterRequirementPatternInstance(ISerializationContext context, OuterRequirementPatternInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PastExtraInvariantPatternInstance returns PastExtraInvariantPatternInstance
	 *
	 * Constraint:
	 *     (
	 *         pattern=[PastExtraInvariantPattern|ID] 
	 *         (cParams+=ConstantParameter cParams+=ConstantParameter*)? 
	 *         (fnParams+=FunctionalParameter fnParams+=FunctionalParameter*)? 
	 *         (fmParams+=RegularFormulaParameter fmParams+=RegularFormulaParameter*)? 
	 *         state=[UpdateStateVariable|ID]
	 *     )
	 * </pre>
	 */
	protected void sequence_PastExtraInvariantPatternInstance(ISerializationContext context, PastExtraInvariantPatternInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns PastExtraInvariantPattern
	 *     PastExtraInvariantPattern returns PastExtraInvariantPattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (cParams+=ConstantParameter cParams+=ConstantParameter*)? 
	 *         (fnParams+=FunctionalParameter fnParams+=FunctionalParameter*)? 
	 *         (fmParams+=RegularFormulaParameter fmParams+=RegularFormulaParameter*)? 
	 *         lemmas=PastLemmas?
	 *     )
	 * </pre>
	 */
	protected void sequence_PastExtraInvariantPattern(ISerializationContext context, PastExtraInvariantPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PastLemmas returns PastLemmas
	 *
	 * Constraint:
	 *     (L4=Lemma | L5=Lemma | L6=Lemma | L7=Lemma)*
	 * </pre>
	 */
	protected void sequence_PastLemmas(ISerializationContext context, PastLemmas semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns PastRequirementPattern
	 *     BasicRequirementPattern returns PastRequirementPattern
	 *     OuterRequirementPattern returns PastRequirementPattern
	 *     PastRequirementPattern returns PastRequirementPattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (cParams+=ConstantParameter cParams+=ConstantParameter*)? 
	 *         (fmParams+=RegularFormulaParameter fmParams+=RegularFormulaParameter*)? 
	 *         extraInvPattern=[PastExtraInvariantPattern|ID] 
	 *         lemmas=PastLemmas?
	 *     )
	 * </pre>
	 */
	protected void sequence_PastRequirementPattern(ISerializationContext context, PastRequirementPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PatternFreeFormulaParameterValue returns PatternFreeFormulaParameterValue
	 *
	 * Constraint:
	 *     (states+=UpdateStateVariable* formula=PatternFreeFormula)
	 * </pre>
	 */
	protected void sequence_PatternFreeFormulaParameterValue(ISerializationContext context, PatternFreeFormulaParameterValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PatternFreeFormula returns PatternFreeFormula
	 *     PatternFreeFormula.PatternFreeFormula_1_0 returns PatternFreeFormula
	 *
	 * Constraint:
	 *     (left=PatternFreeFormula_PatternFreeFormula_1_0 right=PatternFreeFormula)
	 * </pre>
	 */
	protected void sequence_PatternFreeFormula(ISerializationContext context, PatternFreeFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.PATTERN_FREE_FORMULA__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.PATTERN_FREE_FORMULA__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.PATTERN_FREE_FORMULA__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.PATTERN_FREE_FORMULA__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternFreeFormulaAccess().getPatternFreeFormulaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPatternFreeFormulaAccess().getRightPatternFreeFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns PowerTerm
	 *     Term.Term_1_0 returns PowerTerm
	 *     ConjunctionTerm returns PowerTerm
	 *     ConjunctionTerm.ConjunctionTerm_1_0 returns PowerTerm
	 *     NegationTerm returns PowerTerm
	 *     EqTerm returns PowerTerm
	 *     EqTerm.EqTerm_1_0 returns PowerTerm
	 *     CompareTerm returns PowerTerm
	 *     CompareTerm.CompareTerm_1_0 returns PowerTerm
	 *     AddTerm returns PowerTerm
	 *     AddTerm.AddTerm_1_0 returns PowerTerm
	 *     MulTerm returns PowerTerm
	 *     MulTerm.MulTerm_1_0 returns PowerTerm
	 *     PowerTerm returns PowerTerm
	 *     PowerTerm.PowerTerm_1_0 returns PowerTerm
	 *
	 * Constraint:
	 *     (left=PowerTerm_PowerTerm_1_0 right=PowerTerm)
	 * </pre>
	 */
	protected void sequence_PowerTerm(ISerializationContext context, PowerTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerTermAccess().getPowerTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowerTermAccess().getRightPowerTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Formula returns PrimaryFormula
	 *     Formula.Formula_1_0 returns PrimaryFormula
	 *     ConjunctionFormula returns PrimaryFormula
	 *     ConjunctionFormula.Conjunction_1_0 returns PrimaryFormula
	 *     PrimaryFormula returns PrimaryFormula
	 *
	 * Constraint:
	 *     (patternInst=OuterRequirementPatternInstance | nestedFormula=Formula)
	 * </pre>
	 */
	protected void sequence_PrimaryFormula(ISerializationContext context, PrimaryFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InnerFormula returns PrimaryInnerFormula
	 *     InnerFormula.InnerFormula_1_0 returns PrimaryInnerFormula
	 *     ConjunctionInnerFormula returns PrimaryInnerFormula
	 *     ConjunctionInnerFormula.ConjunctionInnerFormula_1_0 returns PrimaryInnerFormula
	 *     PrimaryInnerFormula returns PrimaryInnerFormula
	 *
	 * Constraint:
	 *     (atomic=NegationFormula | patternInst=BasicRequirementPatternInstance | nestedFormula=InnerFormula)
	 * </pre>
	 */
	protected void sequence_PrimaryInnerFormula(ISerializationContext context, PrimaryInnerFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LemmaPremiseFormula returns PrimaryLemmaPremiseFormula
	 *     DisjunctionLemmaPremiseFormula returns PrimaryLemmaPremiseFormula
	 *     DisjunctionLemmaPremiseFormula.DisjunctionLemmaPremiseFormula_1_0 returns PrimaryLemmaPremiseFormula
	 *     ConjunctionLemmaPremiseFormula returns PrimaryLemmaPremiseFormula
	 *     ConjunctionLemmaPremiseFormula.ConjunctionLemmaPremiseFormula_1_0 returns PrimaryLemmaPremiseFormula
	 *     PrimaryLemmaPremiseFormula returns PrimaryLemmaPremiseFormula
	 *
	 * Constraint:
	 *     (atomic=NegationFormula | alwaysImp=AlwaysImplication | inst=PastExtraInvariantPatternInstance | nestedFormula=LemmaPremiseFormula)
	 * </pre>
	 */
	protected void sequence_PrimaryLemmaPremiseFormula(ISerializationContext context, PrimaryLemmaPremiseFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PatternFreeFormula returns PrimaryPatternFreeFormula
	 *     PatternFreeFormula.PatternFreeFormula_1_0 returns PrimaryPatternFreeFormula
	 *     ConjunctionPatternFreeFormula returns PrimaryPatternFreeFormula
	 *     ConjunctionPatternFreeFormula.ConjunctionPatternFreeFormula_1_0 returns PrimaryPatternFreeFormula
	 *     PrimaryPatternFreeFormula returns PrimaryPatternFreeFormula
	 *
	 * Constraint:
	 *     (atomic=NegationFormula | nestedFormula=PatternFreeFormula)
	 * </pre>
	 */
	protected void sequence_PrimaryPatternFreeFormula(ISerializationContext context, PrimaryPatternFreeFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns PrimaryTerm
	 *     Term.Term_1_0 returns PrimaryTerm
	 *     ConjunctionTerm returns PrimaryTerm
	 *     ConjunctionTerm.ConjunctionTerm_1_0 returns PrimaryTerm
	 *     NegationTerm returns PrimaryTerm
	 *     EqTerm returns PrimaryTerm
	 *     EqTerm.EqTerm_1_0 returns PrimaryTerm
	 *     CompareTerm returns PrimaryTerm
	 *     CompareTerm.CompareTerm_1_0 returns PrimaryTerm
	 *     AddTerm returns PrimaryTerm
	 *     AddTerm.AddTerm_1_0 returns PrimaryTerm
	 *     MulTerm returns PrimaryTerm
	 *     MulTerm.MulTerm_1_0 returns PrimaryTerm
	 *     PowerTerm returns PrimaryTerm
	 *     PowerTerm.PowerTerm_1_0 returns PrimaryTerm
	 *     UnaryTerm returns PrimaryTerm
	 *     PrimaryTerm returns PrimaryTerm
	 *
	 * Constraint:
	 *     (const=Constant | variable=[Variable|ID] | funApp=FunApplication | nestedTerm=Term)
	 * </pre>
	 */
	protected void sequence_PrimaryTerm(ISerializationContext context, PrimaryTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns ProgramVariable
	 *     ProgramVariable returns ProgramVariable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_ProgramVariable(ISerializationContext context, ProgramVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NumericLiteral returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     (sig?='-'? value=REAL)
	 * </pre>
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormulaParameter returns RegularFormulaParameter
	 *     RegularFormulaParameter returns RegularFormulaParameter
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_RegularFormulaParameter(ISerializationContext context, RegularFormulaParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.FORMULA_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.FORMULA_PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegularFormulaParameterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Requirement
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (name=ID pattern=[DerivedRequirementPattern|ID] extraInv=[ExtraInvariant|ID])
	 * </pre>
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.REQUIREMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.REQUIREMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.REQUIREMENT__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.REQUIREMENT__PATTERN));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.REQUIREMENT__EXTRA_INV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.REQUIREMENT__EXTRA_INV));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequirementAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRequirementAccess().getPatternDerivedRequirementPatternIDTerminalRuleCall_3_0_1(), semanticObject.eGet(RPLPackage.Literals.REQUIREMENT__PATTERN, false));
		feeder.accept(grammarAccess.getRequirementAccess().getExtraInvExtraInvariantIDTerminalRuleCall_5_0_1(), semanticObject.eGet(RPLPackage.Literals.REQUIREMENT__EXTRA_INV, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormulaParameter returns SimpleFormulaParameter
	 *     SimpleFormulaParameter returns SimpleFormulaParameter
	 *
	 * Constraint:
	 *     (name=ID arity=INTEGER?)
	 * </pre>
	 */
	protected void sequence_SimpleFormulaParameter(ISerializationContext context, SimpleFormulaParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns Term
	 *     Term.Term_1_0 returns Term
	 *
	 * Constraint:
	 *     (left=Term_Term_1_0 right=Term)
	 * </pre>
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermAccess().getTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTermAccess().getRightTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns UnaryTerm
	 *     Term.Term_1_0 returns UnaryTerm
	 *     ConjunctionTerm returns UnaryTerm
	 *     ConjunctionTerm.ConjunctionTerm_1_0 returns UnaryTerm
	 *     NegationTerm returns UnaryTerm
	 *     EqTerm returns UnaryTerm
	 *     EqTerm.EqTerm_1_0 returns UnaryTerm
	 *     CompareTerm returns UnaryTerm
	 *     CompareTerm.CompareTerm_1_0 returns UnaryTerm
	 *     AddTerm returns UnaryTerm
	 *     AddTerm.AddTerm_1_0 returns UnaryTerm
	 *     MulTerm returns UnaryTerm
	 *     MulTerm.MulTerm_1_0 returns UnaryTerm
	 *     PowerTerm returns UnaryTerm
	 *     PowerTerm.PowerTerm_1_0 returns UnaryTerm
	 *     UnaryTerm returns UnaryTerm
	 *
	 * Constraint:
	 *     (unOp=UnMinus right=PrimaryTerm)
	 * </pre>
	 */
	protected void sequence_UnaryTerm(ISerializationContext context, UnaryTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.UNARY_TERM__UN_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.UNARY_TERM__UN_OP));
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryTermAccess().getUnOpUnMinusEnumRuleCall_1_0_0(), semanticObject.getUnOp());
		feeder.accept(grammarAccess.getUnaryTermAccess().getRightPrimaryTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UpdateStateVariable returns UpdateStateVariable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_UpdateStateVariable(ISerializationContext context, UpdateStateVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPLPackage.Literals.UPDATE_STATE_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPLPackage.Literals.UPDATE_STATE_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateStateVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns VarDeclaration
	 *     VarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (vars+=ProgramVariable vars+=ProgramVariable*)
	 * </pre>
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
