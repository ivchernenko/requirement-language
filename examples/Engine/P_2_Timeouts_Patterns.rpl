import "../Basic_Patterns.rpl" ; derivedeinv pattern P_release_2_timeouts_inv ( const : t1 , t2 fun : b_0 , b_1 , t1_0 , b_2 , t1_1 simple formulas : A1 formulas : A2_1 , A3_1 , A4_1 , A5_1 ) lemmas { LS8 lemma P_release_2_timeouts_inv_saving_gen { const : t1 , t2 fun : b_0 , b_1 , t1_0 , b_2 , t1_1 simple formulas : A1 extra invariant formulas : A2_1 , A3_1 , A4_1 , A5_1 init state : s0 final state : s premise ( ( ( ( True AND ( alwaysimp ( s0 , A3_1 ( s0 ) , A3_1 ( s ) ) AND alwaysimp ( s0 , A2_1 ( s0 ) , A2_1 ( s ) ) ) AND ( alwaysimp ( s0 , A4_1 ( s0 ) , A4_1 ( s ) ) AND True ) AND alwaysimp ( s0 , lambda r1 . A5_1 ( s0 , r1 ) , lambda r1 . A5_1 ( s , r1 ) ) ) AND ( frm ( b_0 ( s0 ) ) AND True OR ( frm ( t1 = 0 ) AND A2_1 ( s , s ) OR alwaysimp ( s0 , A3_1 ( s0 ) , A3_1 ( s ) ) AND alwaysimp ( s0 , A2_1 ( s0 ) , A2_1 ( s ) ) AND frm ( b_1 ( s0 ) ) AND frm ( t1 <= t1_0 ( s0 ) + 1 ) AND A3_1 ( s , s ) ) OR ( frm ( t2 = 0 ) AND True OR alwaysimp ( s0 , A4_1 ( s0 ) , A4_1 ( s ) ) AND True AND frm ( b_2 ( s0 ) ) AND frm ( t2 <= t1_1 ( s0 ) + 1 ) AND A4_1 ( s , s ) ) OR A5_1 ( s , s ) ) ) AND ( b_0 ( s ) --> NOT A1 ( s ) ) ) AND ( b_1 ( s ) --> frm ( t1_0 ( s ) = 0 ) AND A2_1 ( s , s ) OR alwaysimp ( s0 , A3_1 ( s0 ) , A3_1 ( s ) ) AND alwaysimp ( s0 , A2_1 ( s0 ) , A2_1 ( s ) ) AND frm ( b_1 ( s0 ) ) AND frm ( t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) AND A3_1 ( s , s ) ) ) AND ( b_2 ( s ) --> frm ( t1_1 ( s ) = 0 ) AND True OR alwaysimp ( s0 , A4_1 ( s0 ) , A4_1 ( s ) ) AND True AND frm ( b_2 ( s0 ) ) AND frm ( t1_1 ( s ) <= t1_1 ( s0 ) + 1 ) AND A4_1 ( s , s ) ) } ; LS9 lemma P_release_2_timeoutseinv_imp_req_gen { const : t1 , t2 fun : b_0 , b_1 , t1_0 , b_2 , t1_1 simple formulas : A1 extra invariant formulas : A2_1 , A3_1 , A4_1 , A5_1 requirement formulas : A2 , A3 , A4 , A5 final state : s0 premise True AND ( alwaysimp ( s0 , A3_1 ( s0 ) , A3 ( s0 ) ) AND alwaysimp ( s0 , A2_1 ( s0 ) , A2 ( s0 ) ) ) AND ( alwaysimp ( s0 , A4_1 ( s0 ) , A4 ( s0 ) ) AND True ) AND alwaysimp ( s0 , lambda r1 . A5_1 ( s0 , r1 ) , lambda r1 . A5 ( s0 , r1 ) ) } ; } ; derivedeinv pattern P_release_2_timeouts_inv_part ( const : t1 , t2 fun : b_0 , b_1 , t1_0 , b_2 , t1_1 simple formulas : A1 , A2 , A3 , A4 , A5 ) lemmas { LS8 lemma P_release_2_timeouts_inv_saving { const : t1 , t2 fun : b_0 , b_1 , t1_0 , b_2 , t1_1 simple formulas : A1 , A2 , A3 , A4 , A5 init state : s0 final state : s premise ( ( ( frm ( b_0 ( s0 ) ) OR ( frm ( t1 = 0 ) AND A2 ( s ) OR frm ( b_1 ( s0 ) ) AND frm ( t1 <= t1_0 ( s0 ) + 1 ) AND A3 ( s ) ) OR ( frm ( t2 = 0 ) OR frm ( b_2 ( s0 ) ) AND frm ( t2 <= t1_1 ( s0 ) + 1 ) AND A4 ( s ) ) OR A5 ( s ) ) AND ( b_0 ( s ) --> NOT A1 ( s ) ) ) AND ( b_1 ( s ) --> frm ( t1_0 ( s ) = 0 ) AND A2 ( s ) OR frm ( b_1 ( s0 ) ) AND frm ( t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) AND A3 ( s ) ) ) AND ( b_2 ( s ) --> frm ( t1_1 ( s ) = 0 ) OR frm ( b_2 ( s0 ) ) AND frm ( t1_1 ( s ) <= t1_1 ( s0 ) + 1 ) AND A4 ( s ) ) } ; LS9 lemma P_release_2_timeoutseinv_imp_req { const : t1 , t2 fun : b_0 , b_1 , t1_0 , b_2 , t1_1 simple formulas : A1 , A2 , A3 , A4 , A5 final state : s premise True } ; } ; derivedreq pattern P_release_2_timeouts ( const : t1 , t2 simple formulas : A1 formulas : A2 , A3 , A4 , A5 ) with P_release_2_timeouts_inv ; derivedreq pattern P_release_2_timeouts_part ( const : t1 , t2 simple formulas : A1 , A2 , A3 , A4 , A5 ) with P_release_2_timeouts_inv_part ;