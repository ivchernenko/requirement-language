import "Basic_Patterns.rpl" ; derivedeinv pattern EDTL_delay_true_inv ( fun : w_0 simple formulas : trigger , fin formulas : release_1 , Inv_1 , reaction_1 ) lemmas { LS8 lemma EDTL_delay_true_inv_saving_gen { fun : w_0 simple formulas : trigger , fin extra invariant formulas : release_1 , Inv_1 , reaction_1 init state : s0 final state : s premise ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release_1 ( s , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) AND True ) AND ( alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release_1 ( s , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction_1 ( s , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) ) AND ( NOT frm ( w_0 ( s0 ) ) OR ( release_1 ( s , s ) OR fin ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( w_0 ( s ) ) AND Inv_1 ( s , s ) AND NOT fin ( s ) ) ) AND ( NOT trigger ( s ) OR release_1 ( s , s ) OR ( release_1 ( s , s ) OR fin ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( w_0 ( s ) ) AND Inv_1 ( s , s ) AND NOT fin ( s ) ) } ; LS9 lemma EDTL_delay_trueeinv_imp_req_gen { fun : w_0 simple formulas : trigger , fin extra invariant formulas : release_1 , Inv_1 , reaction_1 requirement formulas : release , Inv , reaction final state : s0 premise True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release ( s0 , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) AND True ) AND alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release ( s0 , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction ( s0 , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) } ; } ; derivedeinv pattern EDTL_delay_true_inv_part ( fun : w_0 simple formulas : trigger , fin , release , Inv , reaction ) lemmas { LS8 lemma EDTL_delay_true_inv_saving { fun : w_0 simple formulas : trigger , fin , release , Inv , reaction init state : s0 final state : s premise ( NOT frm ( w_0 ( s0 ) ) OR ( release ( s ) OR fin ( s ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( w_0 ( s ) ) AND Inv ( s ) AND NOT fin ( s ) ) AND ( NOT trigger ( s ) OR release ( s ) OR ( release ( s ) OR fin ( s ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( w_0 ( s ) ) AND Inv ( s ) AND NOT fin ( s ) ) } ; LS9 lemma EDTL_delay_trueeinv_imp_req { fun : w_0 simple formulas : trigger , fin , release , Inv , reaction final state : s premise True } ; } ; derivedreq pattern EDTL_delay_true ( simple formulas : trigger , fin formulas : release , Inv , reaction ) with EDTL_delay_true_inv ; derivedreq pattern EDTL_delay_true_part ( simple formulas : trigger , fin , release , Inv , reaction ) with EDTL_delay_true_inv_part ; derivedeinv pattern EDTL_trigger_prev_delay_true_inv ( fun : b_0 , w_0 simple formulas : trigger , fin formulas : release_1 , Inv_1 , reaction_1 ) lemmas { LS8 lemma EDTL_trigger_prev_delay_true_inv_saving_gen { fun : b_0 , w_0 simple formulas : trigger , fin extra invariant formulas : release_1 , Inv_1 , reaction_1 init state : s0 final state : s premise ( ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release_1 ( s , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) AND True ) AND ( alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release_1 ( s , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction_1 ( s , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) ) AND ( NOT frm ( w_0 ( s0 ) ) OR ( release_1 ( s , s ) OR fin ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( w_0 ( s ) ) AND Inv_1 ( s , s ) AND NOT fin ( s ) ) ) AND ( frm ( b_0 ( s0 ) ) AND True OR release_1 ( s , s ) OR ( release_1 ( s , s ) OR fin ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( w_0 ( s ) ) AND Inv_1 ( s , s ) AND NOT fin ( s ) ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) } ; LS9 lemma EDTL_trigger_prev_delay_trueeinv_imp_req_gen { fun : b_0 , w_0 simple formulas : trigger , fin extra invariant formulas : release_1 , Inv_1 , reaction_1 requirement formulas : release , Inv , reaction final state : s0 premise True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release ( s0 , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) AND True ) AND alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release ( s0 , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction ( s0 , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) } ; } ; derivedeinv pattern EDTL_trigger_prev_delay_true_inv_part ( fun : b_0 , w_0 simple formulas : trigger , fin , release , Inv , reaction ) lemmas { LS8 lemma EDTL_trigger_prev_delay_true_inv_saving { fun : b_0 , w_0 simple formulas : trigger , fin , release , Inv , reaction init state : s0 final state : s premise ( ( NOT frm ( w_0 ( s0 ) ) OR ( release ( s ) OR fin ( s ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( w_0 ( s ) ) AND Inv ( s ) AND NOT fin ( s ) ) AND ( frm ( b_0 ( s0 ) ) OR release ( s ) OR ( release ( s ) OR fin ( s ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( w_0 ( s ) ) AND Inv ( s ) AND NOT fin ( s ) ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) } ; LS9 lemma EDTL_trigger_prev_delay_trueeinv_imp_req { fun : b_0 , w_0 simple formulas : trigger , fin , release , Inv , reaction final state : s premise True } ; } ; derivedreq pattern EDTL_trigger_prev_delay_true ( simple formulas : trigger , fin formulas : release , Inv , reaction ) with EDTL_trigger_prev_delay_true_inv ; derivedreq pattern EDTL_trigger_prev_delay_true_part ( simple formulas : trigger , fin , release , Inv , reaction ) with EDTL_trigger_prev_delay_true_inv_part ; derivedeinv pattern EDTL_final_prev_delay_true_inv ( fun : b_0 , b_1 , w_0 simple formulas : trigger , fin formulas : release_1 , Inv_1 , reaction_1 ) lemmas { LS8 lemma EDTL_final_prev_delay_true_inv_saving_gen { fun : b_0 , b_1 , w_0 simple formulas : trigger , fin extra invariant formulas : release_1 , Inv_1 , reaction_1 init state : s0 final state : s premise ( ( ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release_1 ( s , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) AND True ) AND ( alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release_1 ( s , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction_1 ( s , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) ) AND ( NOT frm ( w_0 ( s0 ) ) OR ( release_1 ( s , s ) OR ( frm ( b_1 ( s0 ) ) AND True ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( w_0 ( s ) ) AND Inv_1 ( s , s ) AND frm ( b_0 ( s0 ) ) AND True ) ) AND ( NOT trigger ( s ) OR release_1 ( s , s ) OR ( release_1 ( s , s ) OR ( frm ( b_1 ( s0 ) ) AND True ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( w_0 ( s ) ) AND Inv_1 ( s , s ) AND frm ( b_0 ( s0 ) ) AND True ) ) AND ( b_0 ( s ) --> NOT fin ( s ) ) ) AND ( b_1 ( s ) --> fin ( s ) ) } ; LS9 lemma EDTL_final_prev_delay_trueeinv_imp_req_gen { fun : b_0 , b_1 , w_0 simple formulas : trigger , fin extra invariant formulas : release_1 , Inv_1 , reaction_1 requirement formulas : release , Inv , reaction final state : s0 premise True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release ( s0 , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) AND True ) AND alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release ( s0 , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction ( s0 , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) } ; } ; derivedeinv pattern EDTL_final_prev_delay_true_inv_part ( fun : b_0 , b_1 , w_0 simple formulas : trigger , fin , release , Inv , reaction ) lemmas { LS8 lemma EDTL_final_prev_delay_true_inv_saving { fun : b_0 , b_1 , w_0 simple formulas : trigger , fin , release , Inv , reaction init state : s0 final state : s premise ( ( ( NOT frm ( w_0 ( s0 ) ) OR ( release ( s ) OR frm ( b_1 ( s0 ) ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( w_0 ( s ) ) AND Inv ( s ) AND frm ( b_0 ( s0 ) ) ) AND ( NOT trigger ( s ) OR release ( s ) OR ( release ( s ) OR frm ( b_1 ( s0 ) ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( w_0 ( s ) ) AND Inv ( s ) AND frm ( b_0 ( s0 ) ) ) ) AND ( b_0 ( s ) --> NOT fin ( s ) ) ) AND ( b_1 ( s ) --> fin ( s ) ) } ; LS9 lemma EDTL_final_prev_delay_trueeinv_imp_req { fun : b_0 , b_1 , w_0 simple formulas : trigger , fin , release , Inv , reaction final state : s premise True } ; } ; derivedreq pattern EDTL_final_prev_delay_true ( simple formulas : trigger , fin formulas : release , Inv , reaction ) with EDTL_final_prev_delay_true_inv ; derivedreq pattern EDTL_final_prev_delay_true_part ( simple formulas : trigger , fin , release , Inv , reaction ) with EDTL_final_prev_delay_true_inv_part ; derivedeinv pattern EDTL_trigger_prev_final_prev_delay_true_inv ( fun : b_0 , b_1 , b_2 , w_0 simple formulas : trigger , fin formulas : release_1 , Inv_1 , reaction_1 ) lemmas { LS8 lemma EDTL_trigger_prev_final_prev_delay_true_inv_saving_gen { fun : b_0 , b_1 , b_2 , w_0 simple formulas : trigger , fin extra invariant formulas : release_1 , Inv_1 , reaction_1 init state : s0 final state : s premise ( ( ( ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release_1 ( s , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) AND True ) AND ( alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release_1 ( s , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction_1 ( s , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) ) AND ( NOT frm ( w_0 ( s0 ) ) OR ( release_1 ( s , s ) OR ( frm ( b_2 ( s0 ) ) AND True ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( w_0 ( s ) ) AND Inv_1 ( s , s ) AND frm ( b_1 ( s0 ) ) AND True ) ) AND ( frm ( b_0 ( s0 ) ) AND True OR release_1 ( s , s ) OR ( release_1 ( s , s ) OR ( frm ( b_2 ( s0 ) ) AND True ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( w_0 ( s ) ) AND Inv_1 ( s , s ) AND frm ( b_1 ( s0 ) ) AND True ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) ) AND ( b_1 ( s ) --> NOT fin ( s ) ) ) AND ( b_2 ( s ) --> fin ( s ) ) } ; LS9 lemma EDTL_trigger_prev_final_prev_delay_trueeinv_imp_req_gen { fun : b_0 , b_1 , b_2 , w_0 simple formulas : trigger , fin extra invariant formulas : release_1 , Inv_1 , reaction_1 requirement formulas : release , Inv , reaction final state : s0 premise True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release ( s0 , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) AND True ) AND alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release ( s0 , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction ( s0 , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) } ; } ; derivedeinv pattern EDTL_trigger_prev_final_prev_delay_true_inv_part ( fun : b_0 , b_1 , b_2 , w_0 simple formulas : trigger , fin , release , Inv , reaction ) lemmas { LS8 lemma EDTL_trigger_prev_final_prev_delay_true_inv_saving { fun : b_0 , b_1 , b_2 , w_0 simple formulas : trigger , fin , release , Inv , reaction init state : s0 final state : s premise ( ( ( ( NOT frm ( w_0 ( s0 ) ) OR ( release ( s ) OR frm ( b_2 ( s0 ) ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( w_0 ( s ) ) AND Inv ( s ) AND frm ( b_1 ( s0 ) ) ) AND ( frm ( b_0 ( s0 ) ) OR release ( s ) OR ( release ( s ) OR frm ( b_2 ( s0 ) ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( w_0 ( s ) ) AND Inv ( s ) AND frm ( b_1 ( s0 ) ) ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) ) AND ( b_1 ( s ) --> NOT fin ( s ) ) ) AND ( b_2 ( s ) --> fin ( s ) ) } ; LS9 lemma EDTL_trigger_prev_final_prev_delay_trueeinv_imp_req { fun : b_0 , b_1 , b_2 , w_0 simple formulas : trigger , fin , release , Inv , reaction final state : s premise True } ; } ; derivedreq pattern EDTL_trigger_prev_final_prev_delay_true ( simple formulas : trigger , fin formulas : release , Inv , reaction ) with EDTL_trigger_prev_final_prev_delay_true_inv ; derivedreq pattern EDTL_trigger_prev_final_prev_delay_true_part ( simple formulas : trigger , fin , release , Inv , reaction ) with EDTL_trigger_prev_final_prev_delay_true_inv_part ; derivedeinv pattern EDTL_final_nontemporal_or_tau_delay_true_inv ( const : finalt fun : t1_0 , b_0 , t1_1_0 , t2_1_0 simple formulas : trigger , finale formulas : release_1 , Inv_1 , reaction_1 ) lemmas { LS8 lemma EDTL_final_nontemporal_or_tau_delay_true_inv_saving_gen { const : finalt fun : t1_0 , b_0 , t1_1_0 , t2_1_0 simple formulas : trigger , finale extra invariant formulas : release_1 , Inv_1 , reaction_1 init state : s0 final state : s premise ( ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release_1 ( s , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) AND True ) AND ( alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release_1 ( s , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction_1 ( s , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) ) AND ( frm ( t1_0 ( s0 ) < finalt + 1 ) AND ( ( release_1 ( s , s ) OR finale ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) AND frm ( t1_0 ( s ) <= finalt + 1 + 1 ) OR frm ( t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) AND Inv_1 ( s , s ) AND NOT finale ( s ) ) OR frm ( t1_0 ( s0 ) >= finalt + 1 AND t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) ) ) AND ( NOT trigger ( s ) OR release_1 ( s , s ) OR ( release_1 ( s , s ) OR finale ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( t1_0 ( s ) = 0 ) AND Inv_1 ( s , s ) AND NOT finale ( s ) ) ) AND ( ( ( True AND True ) AND alwaysimp ( s0 , lambda r1 . reaction_1 ( s0 , r1 ) , lambda r1 . reaction_1 ( s , r1 ) ) ) AND ( ( frm ( finalt > 0 ) OR NOT trigger ( s ) OR finale ( s ) ) AND ( finale ( s ) OR frm ( b_0 ( s0 ) ) AND True AND True AND frm ( t1_1_0 ( s0 ) < finalt AND finalt <= t2_1_0 ( s0 ) + 1 ) ) OR reaction_1 ( s , s ) ) ) AND ( b_0 ( s ) --> ( frm ( t1_1_0 ( s ) > 0 ) OR NOT trigger ( s ) OR finale ( s ) ) AND ( finale ( s ) OR frm ( b_0 ( s0 ) ) AND True AND True AND frm ( t1_1_0 ( s0 ) < t1_1_0 ( s ) AND t2_1_0 ( s ) <= t2_1_0 ( s0 ) + 1 ) ) ) } ; LS9 lemma EDTL_final_nontemporal_or_tau_delay_trueeinv_imp_req_gen { const : finalt fun : t1_0 , b_0 , t1_1_0 , t2_1_0 simple formulas : trigger , finale extra invariant formulas : release_1 , Inv_1 , reaction_1 requirement formulas : release , Inv , reaction final state : s0 premise ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release ( s0 , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) AND True ) AND alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release ( s0 , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction ( s0 , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) ) AND ( True AND True ) AND alwaysimp ( s0 , lambda r1 . reaction_1 ( s0 , r1 ) , lambda r1 . reaction ( s0 , r1 ) ) } ; } ; derivedeinv pattern EDTL_final_nontemporal_or_tau_delay_true_inv_part ( const : finalt fun : t1_0 , b_0 , t1_1_0 , t2_1_0 simple formulas : trigger , finale , release , Inv , reaction ) lemmas { LS8 lemma EDTL_final_nontemporal_or_tau_delay_true_inv_saving { const : finalt fun : t1_0 , b_0 , t1_1_0 , t2_1_0 simple formulas : trigger , finale , release , Inv , reaction init state : s0 final state : s premise ( ( frm ( t1_0 ( s0 ) < finalt + 1 ) AND ( ( release ( s ) OR finale ( s ) AND reaction ( s ) AND Inv ( s ) ) AND frm ( t1_0 ( s ) <= finalt + 1 + 1 ) OR frm ( t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) AND Inv ( s ) AND NOT finale ( s ) ) OR frm ( t1_0 ( s0 ) >= finalt + 1 AND t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) ) AND ( NOT trigger ( s ) OR release ( s ) OR ( release ( s ) OR finale ( s ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( t1_0 ( s ) = 0 ) AND Inv ( s ) AND NOT finale ( s ) ) ) AND ( ( frm ( finalt > 0 ) OR NOT trigger ( s ) OR finale ( s ) ) AND ( finale ( s ) OR frm ( b_0 ( s0 ) ) AND frm ( t1_1_0 ( s0 ) < finalt AND finalt <= t2_1_0 ( s0 ) + 1 ) ) OR reaction ( s ) ) AND ( b_0 ( s ) --> ( frm ( t1_1_0 ( s ) > 0 ) OR NOT trigger ( s ) OR finale ( s ) ) AND ( finale ( s ) OR frm ( b_0 ( s0 ) ) AND frm ( t1_1_0 ( s0 ) < t1_1_0 ( s ) AND t2_1_0 ( s ) <= t2_1_0 ( s0 ) + 1 ) ) ) } ; LS9 lemma EDTL_final_nontemporal_or_tau_delay_trueeinv_imp_req { const : finalt fun : t1_0 , b_0 , t1_1_0 , t2_1_0 simple formulas : trigger , finale , release , Inv , reaction final state : s premise True } ; } ; derivedreq pattern EDTL_final_nontemporal_or_tau_delay_true ( const : finalt simple formulas : trigger , finale formulas : release , Inv , reaction ) with EDTL_final_nontemporal_or_tau_delay_true_inv ; derivedreq pattern EDTL_final_nontemporal_or_tau_delay_true_part ( const : finalt simple formulas : trigger , finale , release , Inv , reaction ) with EDTL_final_nontemporal_or_tau_delay_true_inv_part ; derivedeinv pattern EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv ( const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale formulas : release_1 , Inv_1 , reaction_1 ) lemmas { LS8 lemma EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv_saving_gen { const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale extra invariant formulas : release_1 , Inv_1 , reaction_1 init state : s0 final state : s premise ( ( ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release_1 ( s , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) AND True ) AND ( alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release_1 ( s , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction_1 ( s , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) ) AND ( frm ( t1_0 ( s0 ) < finalt + 1 ) AND ( ( release_1 ( s , s ) OR finale ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) AND frm ( t1_0 ( s ) <= finalt + 1 + 1 ) OR frm ( t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) AND Inv_1 ( s , s ) AND NOT finale ( s ) ) OR frm ( t1_0 ( s0 ) >= finalt + 1 AND t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) ) ) AND ( frm ( b_0 ( s0 ) ) AND True OR release_1 ( s , s ) OR ( release_1 ( s , s ) OR finale ( s ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) OR frm ( t1_0 ( s ) = 0 ) AND Inv_1 ( s , s ) AND NOT finale ( s ) ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) ) AND ( ( ( ( True AND True AND True ) AND alwaysimp ( s0 , lambda r1 . reaction_1 ( s0 , r1 ) , lambda r1 . reaction_1 ( s , r1 ) ) ) AND ( ( frm ( finalt > 0 ) OR frm ( b_1 ( s0 ) ) AND True OR finale ( s ) ) AND ( finale ( s ) OR frm ( b_2 ( s0 ) ) AND True AND ( True AND True ) AND frm ( t1_1_0 ( s0 ) < finalt AND finalt <= t2_1_0 ( s0 ) + 1 ) ) OR reaction_1 ( s , s ) ) ) AND ( b_2 ( s ) --> ( frm ( t1_1_0 ( s ) > 0 ) OR frm ( b_1 ( s0 ) ) AND True OR finale ( s ) ) AND ( finale ( s ) OR frm ( b_2 ( s0 ) ) AND True AND ( True AND True ) AND frm ( t1_1_0 ( s0 ) < t1_1_0 ( s ) AND t2_1_0 ( s ) <= t2_1_0 ( s0 ) + 1 ) ) ) ) AND ( b_1 ( s ) --> NOT trigger ( s ) ) } ; LS9 lemma EDTL_trigger_prev_final_nontemporal_or_tau_delay_trueeinv_imp_req_gen { const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale extra invariant formulas : release_1 , Inv_1 , reaction_1 requirement formulas : release , Inv , reaction final state : s0 premise ( True AND alwaysimp ( s0 , lambda r1 . release_1 ( s0 , r1 ) , lambda r1 . release ( s0 , r1 ) ) AND ( alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) AND True ) AND alwaysimp ( s0 , lambda r3 . release_1 ( s0 , r3 ) , lambda r3 . release ( s0 , r3 ) ) AND True AND alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction ( s0 , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) ) AND ( True AND True AND True ) AND alwaysimp ( s0 , lambda r1 . reaction_1 ( s0 , r1 ) , lambda r1 . reaction ( s0 , r1 ) ) } ; } ; derivedeinv pattern EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv_part ( const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale , release , Inv , reaction ) lemmas { LS8 lemma EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv_saving { const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale , release , Inv , reaction init state : s0 final state : s premise ( ( ( frm ( t1_0 ( s0 ) < finalt + 1 ) AND ( ( release ( s ) OR finale ( s ) AND reaction ( s ) AND Inv ( s ) ) AND frm ( t1_0 ( s ) <= finalt + 1 + 1 ) OR frm ( t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) AND Inv ( s ) AND NOT finale ( s ) ) OR frm ( t1_0 ( s0 ) >= finalt + 1 AND t1_0 ( s ) <= t1_0 ( s0 ) + 1 ) ) AND ( frm ( b_0 ( s0 ) ) OR release ( s ) OR ( release ( s ) OR finale ( s ) AND reaction ( s ) AND Inv ( s ) ) OR frm ( t1_0 ( s ) = 0 ) AND Inv ( s ) AND NOT finale ( s ) ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) ) AND ( ( ( frm ( finalt > 0 ) OR frm ( b_1 ( s0 ) ) OR finale ( s ) ) AND ( finale ( s ) OR frm ( b_2 ( s0 ) ) AND frm ( t1_1_0 ( s0 ) < finalt AND finalt <= t2_1_0 ( s0 ) + 1 ) ) OR reaction ( s ) ) AND ( b_2 ( s ) --> ( frm ( t1_1_0 ( s ) > 0 ) OR frm ( b_1 ( s0 ) ) OR finale ( s ) ) AND ( finale ( s ) OR frm ( b_2 ( s0 ) ) AND frm ( t1_1_0 ( s0 ) < t1_1_0 ( s ) AND t2_1_0 ( s ) <= t2_1_0 ( s0 ) + 1 ) ) ) ) AND ( b_1 ( s ) --> NOT trigger ( s ) ) } ; LS9 lemma EDTL_trigger_prev_final_nontemporal_or_tau_delay_trueeinv_imp_req { const : finalt fun : b_0 , t1_0 , b_1 , b_2 , t1_1_0 , t2_1_0 simple formulas : trigger , finale , release , Inv , reaction final state : s premise True } ; } ; derivedreq pattern EDTL_trigger_prev_final_nontemporal_or_tau_delay_true ( const : finalt simple formulas : trigger , finale formulas : release , Inv , reaction ) with EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv ; derivedreq pattern EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_part ( const : finalt simple formulas : trigger , finale , release , Inv , reaction ) with EDTL_trigger_prev_final_nontemporal_or_tau_delay_true_inv_part ; derivedeinv pattern EDTL_release_false_final_tau_delay_tau_inv ( const : fin , delay fun : t1_1_0 , t2_1_0 simple formulas : trigger formulas : Inv_1 , reaction_1 ) lemmas { LS8 lemma EDTL_release_false_final_tau_delay_tau_inv_saving_gen { const : fin , delay fun : t1_1_0 , t2_1_0 simple formulas : trigger extra invariant formulas : Inv_1 , reaction_1 init state : s0 final state : s premise ( True AND alwaysimp ( s0 , Inv_1 ( s0 ) , Inv_1 ( s ) ) AND ( alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction_1 ( s , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) ) AND ( frm ( t2_1_0 ( s0 ) = 0 ) OR frm ( t1_1_0 ( s0 ) >= t2_1_0 ( s0 ) ) OR ( reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) AND frm ( t1_1_0 ( s0 ) + 1 >= fin ) AND frm ( t2_1_0 ( s0 ) <= fin + delay ) OR Inv_1 ( s , s ) AND frm ( t1_1_0 ( s0 ) + 1 >= t1_1_0 ( s ) ) AND frm ( t2_1_0 ( s0 ) < t2_1_0 ( s ) ) ) ) AND ( NOT trigger ( s ) OR frm ( fin = 0 ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) OR Inv_1 ( s , s ) AND frm ( t1_1_0 ( s ) = 0 ) AND frm ( t2_1_0 ( s ) > 0 ) ) } ; LS9 lemma EDTL_release_false_final_tau_delay_taueinv_imp_req_gen { const : fin , delay fun : t1_1_0 , t2_1_0 simple formulas : trigger extra invariant formulas : Inv_1 , reaction_1 requirement formulas : Inv , reaction final state : s0 premise True AND alwaysimp ( s0 , Inv_1 ( s0 ) , Inv ( s0 ) ) AND ( alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction ( s0 , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) ) AND frm ( t2_1_0 ( s0 ) <= fin + delay ) } ; } ; derivedeinv pattern EDTL_release_false_final_tau_delay_tau_inv_part ( const : fin , delay fun : t1_1_0 , t2_1_0 simple formulas : trigger , Inv , reaction ) lemmas { LS8 lemma EDTL_release_false_final_tau_delay_tau_inv_saving { const : fin , delay fun : t1_1_0 , t2_1_0 simple formulas : trigger , Inv , reaction init state : s0 final state : s premise ( frm ( t2_1_0 ( s0 ) = 0 ) OR frm ( t1_1_0 ( s0 ) >= t2_1_0 ( s0 ) ) OR ( reaction ( s ) AND Inv ( s ) ) AND frm ( t1_1_0 ( s0 ) + 1 >= fin ) AND frm ( t2_1_0 ( s0 ) <= fin + delay ) OR Inv ( s ) AND frm ( t1_1_0 ( s0 ) + 1 >= t1_1_0 ( s ) ) AND frm ( t2_1_0 ( s0 ) < t2_1_0 ( s ) ) ) AND ( NOT trigger ( s ) OR frm ( fin = 0 ) AND reaction ( s ) AND Inv ( s ) OR Inv ( s ) AND frm ( t1_1_0 ( s ) = 0 ) AND frm ( t2_1_0 ( s ) > 0 ) ) } ; LS9 lemma EDTL_release_false_final_tau_delay_taueinv_imp_req { const : fin , delay fun : t1_1_0 , t2_1_0 simple formulas : trigger , Inv , reaction final state : s premise frm ( t2_1_0 ( s ) <= fin + delay ) } ; } ; derivedreq pattern EDTL_release_false_final_tau_delay_tau ( const : fin , delay simple formulas : trigger formulas : Inv , reaction ) with EDTL_release_false_final_tau_delay_tau_inv ; derivedreq pattern EDTL_release_false_final_tau_delay_tau_part ( const : fin , delay simple formulas : trigger , Inv , reaction ) with EDTL_release_false_final_tau_delay_tau_inv_part ; derivedeinv pattern EDTL_trigger_prev_release_false_final_tau_delay_tau_inv ( const : fin , delay fun : b_0 , t1_1_0 , t2_1_0 simple formulas : trigger formulas : Inv_1 , reaction_1 ) lemmas { LS8 lemma EDTL_trigger_prev_release_false_final_tau_delay_tau_inv_saving_gen { const : fin , delay fun : b_0 , t1_1_0 , t2_1_0 simple formulas : trigger extra invariant formulas : Inv_1 , reaction_1 init state : s0 final state : s premise ( ( True AND alwaysimp ( s0 , Inv_1 ( s0 ) , Inv_1 ( s ) ) AND ( alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction_1 ( s , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv_1 ( s , r3 ) ) ) AND ( frm ( t2_1_0 ( s0 ) = 0 ) OR frm ( t1_1_0 ( s0 ) >= t2_1_0 ( s0 ) ) OR ( reaction_1 ( s , s ) AND Inv_1 ( s , s ) ) AND frm ( t1_1_0 ( s0 ) + 1 >= fin ) AND frm ( t2_1_0 ( s0 ) <= fin + delay ) OR Inv_1 ( s , s ) AND frm ( t1_1_0 ( s0 ) + 1 >= t1_1_0 ( s ) ) AND frm ( t2_1_0 ( s0 ) < t2_1_0 ( s ) ) ) ) AND ( frm ( b_0 ( s0 ) ) AND True OR frm ( fin = 0 ) AND reaction_1 ( s , s ) AND Inv_1 ( s , s ) OR Inv_1 ( s , s ) AND frm ( t1_1_0 ( s ) = 0 ) AND frm ( t2_1_0 ( s ) > 0 ) ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) } ; LS9 lemma EDTL_trigger_prev_release_false_final_tau_delay_taueinv_imp_req_gen { const : fin , delay fun : b_0 , t1_1_0 , t2_1_0 simple formulas : trigger extra invariant formulas : Inv_1 , reaction_1 requirement formulas : Inv , reaction final state : s0 premise True AND alwaysimp ( s0 , Inv_1 ( s0 ) , Inv ( s0 ) ) AND ( alwaysimp ( s0 , lambda r3 . reaction_1 ( s0 , r3 ) , lambda r3 . reaction ( s0 , r3 ) ) AND alwaysimp ( s0 , lambda r3 . Inv_1 ( s0 , r3 ) , lambda r3 . Inv ( s0 , r3 ) ) ) AND frm ( t2_1_0 ( s0 ) <= fin + delay ) } ; } ; derivedeinv pattern EDTL_trigger_prev_release_false_final_tau_delay_tau_inv_part ( const : fin , delay fun : b_0 , t1_1_0 , t2_1_0 simple formulas : trigger , Inv , reaction ) lemmas { LS8 lemma EDTL_trigger_prev_release_false_final_tau_delay_tau_inv_saving { const : fin , delay fun : b_0 , t1_1_0 , t2_1_0 simple formulas : trigger , Inv , reaction init state : s0 final state : s premise ( ( frm ( t2_1_0 ( s0 ) = 0 ) OR frm ( t1_1_0 ( s0 ) >= t2_1_0 ( s0 ) ) OR ( reaction ( s ) AND Inv ( s ) ) AND frm ( t1_1_0 ( s0 ) + 1 >= fin ) AND frm ( t2_1_0 ( s0 ) <= fin + delay ) OR Inv ( s ) AND frm ( t1_1_0 ( s0 ) + 1 >= t1_1_0 ( s ) ) AND frm ( t2_1_0 ( s0 ) < t2_1_0 ( s ) ) ) AND ( frm ( b_0 ( s0 ) ) OR frm ( fin = 0 ) AND reaction ( s ) AND Inv ( s ) OR Inv ( s ) AND frm ( t1_1_0 ( s ) = 0 ) AND frm ( t2_1_0 ( s ) > 0 ) ) ) AND ( b_0 ( s ) --> NOT trigger ( s ) ) } ; LS9 lemma EDTL_trigger_prev_release_false_final_tau_delay_taueinv_imp_req { const : fin , delay fun : b_0 , t1_1_0 , t2_1_0 simple formulas : trigger , Inv , reaction final state : s premise frm ( t2_1_0 ( s ) <= fin + delay ) } ; } ; derivedreq pattern EDTL_trigger_prev_release_false_final_tau_delay_tau ( const : fin , delay simple formulas : trigger formulas : Inv , reaction ) with EDTL_trigger_prev_release_false_final_tau_delay_tau_inv ; derivedreq pattern EDTL_trigger_prev_release_false_final_tau_delay_tau_part ( const : fin , delay simple formulas : trigger , Inv , reaction ) with EDTL_trigger_prev_release_false_final_tau_delay_tau_inv_part ;